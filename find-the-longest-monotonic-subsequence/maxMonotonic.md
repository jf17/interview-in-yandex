```java
public class Main {

/*
Дан массив чисел a_1, a_2, ..., a_n.
Необходимо найти монотонный подотрезок (то есть строго убывающий или строго возрастающий)
максимальной длины и вернуть пару индексов его начала и конца.

Примеры:
[2, 7, 5, 4, 4, 3] -> [1, 3]
[1, 1] -> {1, 1} // or [0, 0]

public int[] maxMonotonic(int[] a) {
 }

*/


public static int[] maxMonotonic(int[] a) { 
    // start и end хранят индексы начала и конца максимально монотонного подмассива
    int start = 0;
    int end = 0;
    // maxLength хранит длину максимально монотонного подмассива, найденную до текущего момента
    int maxLength = 0;
    
    // currentLength хранит длину текущего монотонного подмассива
    int currentLength = 1;
    // increasing и decreasing - флаги, указывающие на тип монотонности текущего подмассива (возрастания или убывания)
    boolean increasing = false;
    boolean decreasing = false;
    
    for (int i = 1; i < a.length; i++) { // Цикл перебирает элементы массива начиная с второго
        if (a[i] > a[i - 1]) { // Если текущий элемент больше предыдущего, подмассив монотонно возрастает
            if (!increasing) { // Если это первый элемент возрастающего подмассива
                currentLength = 2; // Длина подмассива становится 2 (два элемента)
                increasing = true; // Флаг возрастания устанавливается в TRUE
                decreasing = false; // Флаг убывания сбрасывается в FALSE
            } else { // Если это не первый элемент возрастающего подмассива
                currentLength++; // Длина подмассива увеличивается на 1
            }
        } else if (a[i] < a[i - 1]) { // Если текущий элемент меньше предыдущего, подмассив монотонно убывает
            if (!decreasing) { // Если это первый элемент убывающего подмассива
                currentLength = 2; // Длина подмассива становится 2 (два элемента)
                increasing = false; // Флаг возрастания сбрасывается в FALSE
                decreasing = true; // Флаг убывания устанавливается в TRUE
            } else { // Если это не первый элемент убывающего подмассива
                currentLength++; // Длина подмассива увеличивается на 1
            }
        } else { // Если текущий и предыдущий элементы равны, подмассив прерывается
            increasing = false; // Флаги возрастания и убывания сбрасываются в FALSE
            decreasing = false;
            currentLength = 1; // Длина подмассива становится 1 (один элемент)
        }
        
        if (currentLength > maxLength) { // Если текущий подмассив длиннее предыдущего максимального
            maxLength = currentLength; // Обновляем длину максимально монотонного подмассива
            start = i - currentLength + 1; // start индекса первого элемента нового подмассива
            end = i; // end индекса последнего элемента нового подмассива
        }
    }
    
    return new int[]{start, end}; // Возвращаем массив с индексами начала и конца максимально монотонного подмассива
}

    public static void printArrayInRange(int[] arr, int startIndex, int endIndex) {
        for (int i = startIndex; i <= endIndex; i++) {
            System.out.print(arr[i] + ", ");
        }
        System.out.println();
    }

public static void main(String[] args) { 
     int[] arr1 = {2, 7, 5, 4, 4, 3};
     int[] arr2 = {1, 2, 3, 3, 3, 2, 3, 4, 5, 6, 8, 9, 10, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};

     int[] result1 = maxMonotonic(arr1);
     int[] result2 = maxMonotonic(arr2);

     System.out.println("arr1 = [" + result1[0] + ", " + result1[1] + "]"); // Выводим индексы максимально монотонного подмассива для arr1
     printArrayInRange(arr1,result1[0],result1[1]);

     System.out.println();

     System.out.println("arr2 = [" + result2[0] + ", " + result2[1] + "]"); // Выводим индексы максимально монотонного подмассива для arr2
     printArrayInRange(arr2,result2[0],result2[1]);
        }
    }
```

 

**Описание:**

Функция `maxMonotonic` находит  в заданном массиве `a` наиболее длинный монотонный (возрастающий или убывающий) подмассив и возвращает массив из двух элементов: индекс начала и индекса конца этого подмассива.



### Пошаговое объяснение кода:


1. **Инициализация**:
   -  `start`, `end`: хранят индексы начала и конца максимально монотонного подмассива, найденного до текущего момента.
   -  `maxLength`: хранит длину максимально монотонного подмассива, найденную до текущего момента. 

2. **Проход по массиву**: Цикл `for` перебирает каждый элемент массива `a`, начиная со второго (`i = 1`).


3. **Определение типа монотонности**:
   -  Если текущий элемент `a[i]` больше предыдущего `a[i - 1]`, подмассив является монотонно возрастающим (`increasing = true`, `decreasing = false`).
   -  Если текущий элемент меньше предыдущего, подмассив является монотонно убывающим (`increasing = false`, `decreasing = true`).


4. **Обновление длины подмассива**: 
   - Если подмассив остается монотонным, `currentLength` увеличивается на 1.

5. **Перехват изменения типа монотонности**: 
   -  Если элементы перестали быть монотонными (`a[i] == a[i - 1]`), `increasing` и `decreasing` сбрасываются в `false`, а `currentLength` устанавливается в 1.

6. **Обновление максимально длинного подмассива**:
   -  Если `currentLength` больше `maxLength`, то:
      - `maxLength` обновляется на `currentLength`.
      - `start` и `end` устанавливаются на индексы начала и конца текущего подмассива.



7. **Возвращение результатов**: 
    - Функция возвращает массив из двух элементов (`start`, `end`), представляющих начало и конец максимально монотонного подмассива.





